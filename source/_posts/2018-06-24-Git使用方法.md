---
title: Git使用方法
tags: Git
abbrlink: ab888b92
date: 2018-06-24 09:29:39
---

集中式版本控制系统：版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器

集中式版本控制系统最大的毛病就是必须联网才能工作，在局域网内还好

分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。

分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。



集中式版本控制：CVS、SVN、ClearCase、VSS
分布式版本控制：Git、BitKeeper、Mercurial、Bazaar


<!--more-->
## 安装Git

```
sudo apt install git
```

## 配置


```
git config --global user.name "Your Name"
git config --global user.email "email@example.com"
```

##  添加和提交
```
mkdir learngit
cd learngit
git init
# 创建一个新的git存储库

git add .
git add readme.txt
# 实际上是把文件修改添加到暂存区

git commit -m "增加文件"
# 提交更改，实际上是把暂存区的所有内容提交到当前分支
```



```
git status
# 仓库当前的状态
```

```
git diff readme.txt
# 查看修改内容

git diff HEAD --readme.txt

```

```
git log
# 查看提交历史，以便确定要回退到哪个版本，时间从最近到最远
git log --pretty=oneline
# 简要格式，commit id  
```

在Git中，用`HEAD`表示当前版本，上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，往上100个版本写成`HEAD~100`。


```
git reset --hard HEAD^
# 回退到上个版本

git reset --hard 1094adb
# 回退到指定的commit id，commit id可以只写前几位

git log
# 这里无法查看指定的commit id之后的版本，可以使用git relog

git relog
# 查看命令历史，以便确定要回到未来的哪个版本commit id
```

```
git diff
# 工作区(work dict)和暂存区(stage)的比较
git diff --cached
# 暂存区(stage)和分支(master)的比较
```


## 撤销修改


场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- file`。

场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD <file>`，就回到了场景1，第二步按场景1操作。

场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。

```
git checkout -- readme.txt
# 未git add，回退到文件修改之前（丢弃工作区的修改），不需要直接修改文件

 git reset HEAD readme.txt
# 已经git add（添加到了暂存区），需要回退未git add 之前
```


## 删除文件

当你要删除文件的时候，可以采用命令：`rm test.txt`

这个时候（也就是说这个时候只执行了rm test.txt）有两种情况

第一种情况:的确要把test.txt删掉，那么可以执行
```
git rm test.txt
git commit -m "remove test.txt"
```
然后文件就被删掉了
第二种情况:删错文件了，不应该删test.txt，注意这时只执行了rm test.txt，还没有提交，所以可以执行`git checkout test.txt`将文件恢复。

并不是说执行完git commit -m "remove test.txt"后还能用checkout恢复，commit之后版本库里的文件也没了，自然没办法用checkout恢复，而是要用其他的办法






## 添加远程库
先有本地库，后有远程库的时候，如何关联远程库
1. 在github上创建仓库
2. 在本地的learngit仓库下运行命令：
```
git remote add origin git@github.com:michaelliao/learngit.git
```
添加后，远程库的名字就是`origin，这是Git默认的叫法
3. 把本地库的内容推送到远程，用`git push`命令，实际上是把当前分支master推送到远程
```
git push -u origin master
# 可以把 master 换成你想要推送的任何分支
# origin可以换成你想用的名字，但是一般用origin
```

由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令，以后只要执行以下命令即可
```
$ git push origin master
```



### 从远程库克隆
先创建远程库，然后，从远程库克隆


```
$ git clone git@github.com:michaelliao/gitskills.git
```
Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。



## 分支管理


### 创建与合并分支

`master`主分支
`HEAD`指向的就是当前分支
一开始的时候，`master`分支是一条线，Git用`master`指向最新的提交，再用`HEAD`指向`master`，就能确定当前分支，以及当前分支的提交点
每次提交，`master`分支都会向前移动一步，这样，随着你不断提交，`master`分支的线也越来越长

当我们创建新的分支，例如`dev`时，Git新建了一个指针叫`dev`，指向`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上
```
git pull
# 更新本地仓库至最新改动

git checkout -b dev
# 创建并切换分支

git branch
# 列出所有分支，当前分支前面会标一个*号

git branch dev
# 查看当前分支

git checkout dev
# 切换分支

git add readme.txt
git commit -m "branch test"

git checkout master
git merge dev
# 把dev分支的工作成果合并到master分支上

git branch -d dev
# 删除分支
```

直接把`master`指向`dev`的当前提交，就完成了合并
删除`dev`分支就是把`dev`指针给删掉


`git merge`命令用于合并指定分支到当前分支



### 解决冲突

不同的分支各自都分别有新的提交，当进行合并时就会发生冲突，必须手动解决冲突后再提交。`git status`也可以告诉我们冲突的文件


修改文件中的冲突后可以再次提交


用`git log --graph`命令可以看到分支合并图产品


git有个最佳实践，master是主分支，用来做正式发布版之后的保留历史，其他分支包括dev用来做正常开发，多个feature用来做某些特性功能，release用来做发布版历史，每次发布都是用release打包，hotfix用来做发布版之后的一些及时迭代修复bug的工作。


合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而`fast forward`合并就看不出来曾经做过合并
```
git merge --no-ff -m "merge with no-ff" dev
```


### Bug分支
每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。

假定需要在master分支上修复，就从master创建临时分支
```
git stash
# 保存现场工作

git checkout master
git checkout -b issue-101
git add readme.txt 
git commit -m "fix bug 101"
git checkout master
git merge --no-ff -m "merged bug fix 101" issue-101

git checkout dev
# 切换到之前的工作分支
git stash list
# 列出保存的工作现场
git stash pop
# 恢复的同时把stash内容也删了
```

### Feature分支
添加一个新功能
```
git checkout -b feature-vulcan
# 原来在dev分支

git add vulcan.py
git commit -m "add feature vulcan"
git checkout dev
```

```
git branch -D feature-vulcan
# 强行删除分支，未合并之前删除使用
```



### 多人协作

```
git push origin master
git push origin dev
# 推送分支

git clone git@github.com:michaelliao/learngit.git
git branch
# 默认是master分支
git checkout -b dev origin/dev
# 创建dev分支

git pull
git branch --set-upstream-to=origin/dev dev
# 解决冲突
```



![](/img/IMG144.jpg)






## 标签管理
发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。



```
git branch
git checkout master
# 切换到需要打标签的分支上

git tag v1.0
# 打一个新标签

git tag
# 查看所有标签

git log --pretty=oneline --abbrev-commit
git tag v0.9 f52c633
# 针对某一commit id打标签

git show v0.9
# 查看标签信息

git tag -a v0.1 -m "version 0.1 released" 1094adb
# -a指定标签名，-m指定说明文字
```


```
git tag -d v0.1
# 删除一个本地标签

git push origin v1.0
# 推送某个标签到远程
git push origin --tags
# 一次性推送全部尚未推送到远程的本地标签

git tag -d v0.9
git push origin :refs/tags/v0.9
# 删除推送到远程的标签
```


## 一个本地库关联多个远程库

```
git remote -v
# 查看远程库信息
```

```
git remote rm origin
# 先删除已关联的名为origin的远程库


git remote add github git@github.com:michaelliao/learngit.git
git remote add gitee git@gitee.com:liaoxuefeng/learngit.git
# 关联远程库，远程库的名称叫github、gitee

```



## 忽略特殊文件


忽略某些文件时，需要编写`.gitignore`
`.gitignore`文件本身要放到版本库里，并且可以对`.gitignore`做版本管理
参考模版：https://github.com/github/gitignore




## 配置别名


加上`--global`是针对**当前用户**起作用的，如果不加，那只针对**当前的仓库**起作用
```
git config --global alias.st status
git config --global alias.co checkout
git config --global alias.ci commit
git config --global alias.br branch

```

使用配置文件
每个仓库的Git配置文件`.git/config`
当前用户的配置文件`~/.gitconfig`






## 搭建Git服务器

1.安装git
```
sudo apt install git
```

2.创建用户 
```
sudo adduser git -s /usr/sbin/nologin
```



3.管理公钥
收集所有需要登录的用户的公钥，就是他们自己的`id_rsa.pub`文件，把所有公钥导入到`/home/git/.ssh/authorized_keys`文件里，一行一个
人多可以用`Gitosis`来管理公钥


4.初始化Git仓库
选定一个目录作为Git仓库
```
cd 
mkdir gitre
cd gitre
git init --bare sample.git

chown -R git:git sample.git
```


5.禁用shell登录
创建用户时指定

6.克隆远程仓库
在各自的电脑上克隆远程仓库
```
 git clone git@server:/srv/sample.git
```


Git不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。`Gitolite`就是这个工具。









参考：
- [比较全面的 Git 学习资料整理](https://juejin.im/entry/586eddf6a22b9d00587829ce)
- http://www.cylong.com/blog/2016/09/26/git-svn/
- http://rogerdudler.github.io/git-guide/
- https://guides.github.com/activities/hello-world/
- [分布式和集中式版本控制工具-svn,git,mercurial](http://www.uml.org.cn/pzgl/201207264.asp)







---
title: Git使用方法
tags: Git
abbrlink: ab888b92
date: 2018-06-24 09:29:39
---


## 版本控制系统
**集中式版本控制系统**（Centralized Version Control Systems,简称 CVCS）：have a single server that contains all the versioned files, and a number of clients that check out files from that central place.

集中式版本控制系统的缺点是中央服务器的单点故障。

**分布式版本控制系统**（Distributed Version Control System,简称 DVCS）：clients don’t just check out the latest snapshot of the files; rather, they fully mirror the repository, including its full history.

分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。


集中式版本控制：CVS、SVN、ClearCase、VSS
分布式版本控制：Git、BitKeeper、Mercurial、Bazaar


git和其他版本控制工具存储数据的方式不同：
- 其他版本控制工具存储一组文件以及基于这些文件随时间推移产生的差异
- git存储更像快照，对当时的全部文件制作一个快照并保存这个快照的索引，如果没有修改则只保留一个指向之前存储文件的链接

在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息
SVN 中可以修改文件，但是无法向数据库提交修改


Git 中所有数据在存储前都计算**校验和**，然后以校验和来引用，
校验和由 40 个十六进制字符组成，通过SHA1计算得出。Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。


<!--more-->

## Git的作用
1. 备份文件
2. 记录历史
3. 回到过去
4. 多端共享
5. 团队协作


## 安装Git

```
sudo apt install git
sudo yum install git
```

## 配置
```
git config
```
### 配置文件
1. `/etc/gitconfig`，系统配置，`git config --system`
2. `~/.gitconfig` 或 `~/.config/git/config`，当前用户，`git config --global`
3. 项目目录下的`.git/config`，当前仓库

当前仓库会覆盖当前用户配置，当前用户配置会覆盖系统配置


### 用户信息
```
git config --global user.name "Your Name"
git config --global user.email "email@example.com"
```
全局配置只需设置一次
当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 `--global` 选项的命令来配置


### 列出所有配置
```
git config --list
```

### 配置别名
```
git config --global alias.st status
# git st
git config --global alias.co checkout
# git co
git config --global alias.ci commit
# git ci
git config --global alias.br branch
# git br
```


## 初始化

### 在现有目录中初始化仓库
```
cd <dir-name>
git init
```


### 克隆现有的仓库 
```
git clone git@github.com:fengrenxiaoli/GitTest.git
# 在当前目录下创建一个 GitTest 目录，并在 GitTest 目录下创建 .git 文件夹

git clone git@github.com:fengrenxiaoli/GitTest.git mylibgit
# 在当前目录下创建一个 mylibgit 目录，并在 mylibgit 目录下创建 .git 文件夹
```


## 检查当前文件状态
```
git status
```
![](/img/IMG149.png)

tracked：已跟踪，那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区
untracked：未跟踪，其他文件，使用`git add <file-name>`变为跟踪状态

### 三种状态和三个工作区域


| 状态 | 工作区域 | 命令 |
|--|--|  |
|已修改modifed    |  Working Direcroty||
|已暂存staged     |  Stage/Index |`git add <file-name>`|
|已提交commited    | Local Repository/.git目录 |`git commit` |
`git add`既可以用该命令开始跟踪新文件，也可以把已跟踪的文件放到暂存区


## 查看修改
```
git diff
git diff readme.txt
# 查看修改之后还没有暂存起来的修改内容(git add前)
# 比较的是工作目录中当前文件和暂存区域快照之间的差异

git diff HEAD --readme.txt

git diff --cached
# 查看已暂存的将要添加到下次提交里的内容(git add后)
```



##  添加和提交
```
mkdir learngit
cd learngit
git init
# 创建一个新的git存储库

git add .
git add readme.txt
# 实际上是把文件修改添加到暂存区

git commit -m "增加文件"
# 提交更改，实际上是把暂存区的所有内容提交到当前分支
```




## 忽略特殊文件

忽略某些文件时，需要编写`.gitignore`
`.gitignore`文件本身要放到版本库里，并且可以对`.gitignore`做版本管理
参考模版：https://github.com/github/gitignore

文件 `.gitignore` 的格式规范如下:
• 所有空行或者以 `#` 开头的行都会被 Git 忽略。
• 可以使用标准的 `glob` 模式（通配符模式）匹配。
• 以 `/` 开头防止递归。
• 以 `/` 结尾表示目录。
• 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号(!)取反。





```
git log
# 查看提交历史，以便确定要回退到哪个版本，时间从最近到最远
git log --pretty=oneline
# 简要格式，commit id  
```

在Git中，用`HEAD`表示当前版本，上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，往上100个版本写成`HEAD~100`。


```
git reset --hard HEAD^
# 回退到上个版本

git reset --hard 1094adb
# 回退到指定的commit id，commit id可以只写前几位

git log
# 这里无法查看指定的commit id之后的版本，可以使用git relog

git relog
# 查看命令历史，以便确定要回到未来的哪个版本commit id
```

```
git diff
# 工作区(work dict)和暂存区(stage)的比较
git diff --cached
# 暂存区(stage)和分支(master)的比较
```


## 撤销修改


场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- file`。

场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD <file>`，就回到了场景1，第二步按场景1操作。

场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。

```
git checkout -- readme.txt
# 未git add，回退到文件修改之前（丢弃工作区的修改），不需要直接修改文件

 git reset HEAD readme.txt
# 已经git add（添加到了暂存区），需要回退未git add 之前
```


## 删除文件

当你要删除文件的时候，可以采用命令：`rm test.txt`

这个时候（也就是说这个时候只执行了rm test.txt）有两种情况

第一种情况:的确要把test.txt删掉，那么可以执行
```
git rm test.txt
git commit -m "remove test.txt"
```
然后文件就被删掉了
第二种情况:删错文件了，不应该删test.txt，注意这时只执行了rm test.txt，还没有提交，所以可以执行`git checkout test.txt`将文件恢复。

并不是说执行完git commit -m "remove test.txt"后还能用checkout恢复，commit之后版本库里的文件也没了，自然没办法用checkout恢复，而是要用其他的办法






## 添加远程库
先有本地库，后有远程库的时候，如何关联远程库
1.在github上创建仓库
2.在本地的learngit仓库下运行命令：
```
git remote add origin git@github.com:michaelliao/learngit.git
```
添加后，远程库的名字就是`origin，这是Git默认的叫法
3.把本地库的内容推送到远程，用`git push`命令，实际上是把当前分支master推送到远程
```
git push -u origin master
# 可以把 master 换成你想要推送的任何分支
# origin可以换成你想用的名字，但是一般用origin
```

由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令，以后只要执行以下命令即可
```
$ git push origin master
```



### 从远程库克隆
先创建远程库，然后，从远程库克隆


```
$ git clone git@github.com:michaelliao/gitskills.git
```
Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。



## 分支管理


### 创建与合并分支

`master`主分支
`HEAD`指向的就是当前分支
一开始的时候，`master`分支是一条线，Git用`master`指向最新的提交，再用`HEAD`指向`master`，就能确定当前分支，以及当前分支的提交点
每次提交，`master`分支都会向前移动一步，这样，随着你不断提交，`master`分支的线也越来越长

当我们创建新的分支，例如`dev`时，Git新建了一个指针叫`dev`，指向`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上
```
git pull
# 更新本地仓库至最新改动

git checkout -b dev
# 创建并切换分支

git branch
# 列出所有分支，当前分支前面会标一个*号

git branch dev
# 查看当前分支

git checkout dev
# 切换分支

git add readme.txt
git commit -m "branch test"

git checkout master
git merge dev
# 把dev分支的工作成果合并到master分支上

git branch -d dev
# 删除分支
```

直接把`master`指向`dev`的当前提交，就完成了合并
删除`dev`分支就是把`dev`指针给删掉


`git merge`命令用于合并指定分支到当前分支



### 解决冲突

不同的分支各自都分别有新的提交，当进行合并时就会发生冲突，必须手动解决冲突后再提交。`git status`也可以告诉我们冲突的文件


修改文件中的冲突后可以再次提交


用`git log --graph`命令可以看到分支合并图产品


git有个最佳实践，master是主分支，用来做正式发布版之后的保留历史，其他分支包括dev用来做正常开发，多个feature用来做某些特性功能，release用来做发布版历史，每次发布都是用release打包，hotfix用来做发布版之后的一些及时迭代修复bug的工作。


合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而`fast forward`合并就看不出来曾经做过合并
```
git merge --no-ff -m "merge with no-ff" dev
```


### Bug分支
每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。

假定需要在master分支上修复，就从master创建临时分支
```
git stash
# 保存现场工作

git checkout master
git checkout -b issue-101
git add readme.txt 
git commit -m "fix bug 101"
git checkout master
git merge --no-ff -m "merged bug fix 101" issue-101

git checkout dev
# 切换到之前的工作分支
git stash list
# 列出保存的工作现场
git stash pop
# 恢复的同时把stash内容也删了
```

### Feature分支
添加一个新功能
```
git checkout -b feature-vulcan
# 原来在dev分支

git add vulcan.py
git commit -m "add feature vulcan"
git checkout dev
```

```
git branch -D feature-vulcan
# 强行删除分支，未合并之前删除使用
```



### 多人协作

```
git push origin master
git push origin dev
# 推送分支

git clone git@github.com:michaelliao/learngit.git
git branch
# 默认是master分支
git checkout -b dev origin/dev
# 创建dev分支

git pull
git branch --set-upstream-to=origin/dev dev
# 解决冲突
```



![](/img/IMG144.jpg)






## 标签管理
发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。



```
git branch
git checkout master
# 切换到需要打标签的分支上

git tag v1.0
# 打一个新标签

git tag
# 查看所有标签

git log --pretty=oneline --abbrev-commit
git tag v0.9 f52c633
# 针对某一commit id打标签

git show v0.9
# 查看标签信息

git tag -a v0.1 -m "version 0.1 released" 1094adb
# -a指定标签名，-m指定说明文字
```


```
git tag -d v0.1
# 删除一个本地标签

git push origin v1.0
# 推送某个标签到远程
git push origin --tags
# 一次性推送全部尚未推送到远程的本地标签

git tag -d v0.9
git push origin :refs/tags/v0.9
# 删除推送到远程的标签
```


## 一个本地库关联多个远程库

```
git remote -v
# 查看远程库信息
```

```
git remote rm origin
# 先删除已关联的名为origin的远程库


git remote add github git@github.com:michaelliao/learngit.git
git remote add gitee git@gitee.com:liaoxuefeng/learngit.git
# 关联远程库，远程库的名称叫github、gitee

```











## 分支开发

1. 基于主分支创建个开发分支   `git checkout -b dev1`
2. 在开发分支中拉取下主分支   `git pull origin master`
3. 开发完成后，提交到git服务器     `git add` . / `git commit -m '1' `/ `git push origin dev1`
4. 拉取下主分支，提前解决冲突 `git pull origin master`
5. 切回主分支(切记要提交后切回)     `git checkout master`
6. 拉取下最新代码  `git pull origin master `
7. 合并开发分支   `git merge dev1`(如果失败会提示失败文件，解决掉冲突)
8. 提交到git服务器



## 搭建Git服务器

以下方式为通过ssh协议搭建的Git服务器，添加了公钥的用户可以进行读写操作

1.安装git
```
sudo apt install git
```

2.创建用户 
```
cat /etc/shells
which git-shell
sudo vim /etc/shells
# 添加git-shell的位置，git-shell可以禁止使用ssh登录shell

sudo adduser git -s /usr/bin/git-shell
```



3.管理公钥
收集所有需要登录的用户的公钥，就是他们自己的`id_rsa.pub`文件，把所有公钥导入到`/home/git/.ssh/authorized_keys`文件里，一行一个
人多可以用`Gitosis`来管理公钥

注意权限
```
su git
cd
mkdir .ssh
chmod 700 .ssh
touch .ssh/authorized_keys
chmod 600 .ssh/authorized_keys

cat /tmp/id_rsa.john.pub >> ~/.ssh/authorized_keys
cat /tmp/id_rsa.josie.pub >> ~/.ssh/authorized_keys
```


4.初始化Git仓库
选定一个目录作为Git仓库
```
cd /opt/git
mkdir project.git
cd project.git
git init --bare

chown -R git:git project.git
```


需要有一个人推送第一个版本
```
cd myproject
git init
git add .
git commit -m 'initial commit'
git remote add origin git@gitserver:/opt/git/project.git
git push origin master
```


5.克隆远程仓库
在各自的电脑上克隆远程仓库
```
 git clone git@server:/srv/sample.git
```


Git不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。`Gitolite`就是这个工具。


还有其他方式，比如适合快速只读访问的Git守护进程，既可以进行授权访问又可以进行无授权访问的Smart HTTP，使用GitWeb搭建网页展示，参考Pro-git



![](/img/IMG148.png)


利用工具提升工作效率，而不是去学习工具本身
1. 多用客户端和工具，少用命令行，除非在linux服务器上直接开发
2. 每次提交前，diff自己的代码，以免提交错误的代码
3. 下班回家前，整理好自己的工作区
4. 并行的项目，使用分支开发
5. 遇到冲突时，搞明白冲突的原因，千万不要随意丢弃别人的代码


参考：
- [比较全面的 Git 学习资料整理](https://juejin.im/entry/586eddf6a22b9d00587829ce)
- http://www.cylong.com/blog/2016/09/26/git-svn/
- http://rogerdudler.github.io/git-guide/
- https://guides.github.com/activities/hello-world/
- [分布式和集中式版本控制工具-svn,git,mercurial](http://www.uml.org.cn/pzgl/201207264.asp)
- [Git在工作中的小总结](https://www.jianshu.com/p/86ef009e5c86)





